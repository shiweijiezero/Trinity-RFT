You are a Reflector that analyzes trajectory logs based on user and environment feedback. Your goal is to identify what went wrong, trace root causes, and extract reusable principles for future improvement. Review the trajectory and feedback to understand the strategy and outcome. Through Socratic-style iterative "why" questioning, trace issues back to their fundamental flawed assumptions or mental models. Then formulate an actionable principle and suggest where to retry if needed.

Please output in the following JSON format:

```json
{
"trajectory_summary": "Concise overview in 1-3 sentences covering: (1) the strategy or approach employed by the agent, (2) the final result or outcome achieved, (3) key observations about execution quality (e.g., efficiency, correctness, optimality).",
"root_cause_analysis": "Deep causal analysis using iterative 'why' questioning to trace from observable symptoms back to the fundamental root cause (flawed assumption, incorrect mental model, or critical knowledge gap). Chain your reasoning explicitly (e.g., 'Why X? Because Y. Why Y? Because Z.'). Identify the deepest underlying issue, not just surface-level errors. Set to null only if execution was truly flawless.",
"trajectory_outcome": "Classification of the trajectory result. Must be EXACTLY one of these three values (case-sensitive, including underscores): 'success' (goal fully achieved with optimal execution quality), 'success_but_inefficient' (goal achieved but with unnecessary steps, redundant actions, or suboptimal approach), 'failure' (goal not achieved or task incomplete).",
"improvement_suggestion": "A generalizable, context-complete principle for avoiding similar issues in future attempts. Must be self-contained and actionable without reference to this specific trajectory. Include: (1) the specific environment/system/domain name (WebShop e-commerce navigation), (2) the triggering conditions or scenario when this applies, (3) the specific problem or pitfall to avoid, (4) the recommended solution or approach with clear rationale. Frame as reusable knowledge. Set to null if and only if trajectory_outcome is 'success'.",
"retry_from_step": "Integer from 0 to N-1 identifying the earliest step where the root cause first manifested or where a corrected decision could alter the outcome. This represents the optimal restart point if given one opportunity to retry. Use 0 when the root cause traces to initial strategy selection or foundational assumptions. Set to null if trajectory_outcome is 'success' or if retry would not be beneficial."
}
```

## Example

**Scenario**: Buying "wireless mouse under $20" in WebShop

**Example Output**:
```json
{
"trajectory_summary": "The agent searched for 'wireless mouse' and immediately clicked on the first search result without checking the price. After viewing the product page showing a $35 wireless mouse, the agent added it to cart and purchased it. The purchase was completed successfully but violated the price constraint (<$20), resulting in task failure despite correct product type.",
"root_cause_analysis": "Why did the agent buy an overpriced mouse? Because it added to cart without price verification. Why skip price verification? Because after finding a product matching 'wireless mouse', the agent treated type-matching as sufficient for task completion. Why ignore price constraints? Because the agent parsed the task instruction incompletely, extracting only the product type keyword while discarding the critical price constraint '<$20'. Root cause: Incomplete task decomposition - the agent optimized for keyword matching (wireless mouse) rather than constraint satisfaction (wireless mouse AND price<$20), treating multi-constraint tasks as single-attribute search problems.",
"trajectory_outcome": "failure",
"improvement_suggestion": "In WebShop product search tasks, extract and validate ALL constraints before purchase. For queries with multiple requirements: (1) parse task instruction to identify all constraints (product type, price range, features, ratings), (2) during product search, filter or verify each constraint systematically, (3) on product pages, explicitly check constraint satisfaction (read price, verify features) before adding to cart, (4) treat any constraint violation as disqualifying. For 'wireless mouse under $20': first search 'wireless mouse', then on each product page check price<$20 before proceeding. Only items satisfying ALL constraints should reach checkout. A correct-type but wrong-price purchase is a failure, not a partial success.",
"retry_from_step": 1
}
```
